<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pubnub C-core Qt Library: pubnub_qt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pubnub C-core Qt Library
   </div>
   <div id="projectbrief">PubnubC-coreclientlibraryforQtframework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pubnub_qt Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Pubnub client "context" for Qt.  
 <a href="classpubnub__qt.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pubnub__qt_8h_source.html">pubnub_qt.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pubnub_qt:</div>
<div class="dyncontent">
<div class="center"><img src="classpubnub__qt__inherit__graph.png" border="0" usemap="#pubnub__qt_inherit__map" alt="Inheritance graph"/></div>
<map name="pubnub__qt_inherit__map" id="pubnub__qt_inherit__map">
<area shape="rect"  title="Pubnub client &quot;context&quot; for Qt." alt="" coords="5,79,90,104"/>
<area shape="rect"  title=" " alt="" coords="12,5,83,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for pubnub_qt:</div>
<div class="dyncontent">
<div class="center"><img src="classpubnub__qt__coll__graph.png" border="0" usemap="#pubnub__qt_coll__map" alt="Collaboration graph"/></div>
<map name="pubnub__qt_coll__map" id="pubnub__qt_coll__map">
<area shape="rect"  title="Pubnub client &quot;context&quot; for Qt." alt="" coords="5,79,90,104"/>
<area shape="rect"  title=" " alt="" coords="12,5,83,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac78b2594c752a5770c2f3b1b8be464ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ac78b2594c752a5770c2f3b1b8be464ff">ssl_opt</a> { <a class="el" href="classpubnub__qt.html#ac78b2594c752a5770c2f3b1b8be464ffa996f6933fbbf34a8e40a453e777a5612">useSSL</a> = 0x01, 
<a class="el" href="classpubnub__qt.html#ac78b2594c752a5770c2f3b1b8be464ffa86f3a81927bb32b5d1d15df0ece0b8a8">ignoreSecureConnectionRequirement</a> = 0x02
 }</td></tr>
<tr class="memdesc:ac78b2594c752a5770c2f3b1b8be464ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for SSL/TLS transport.  <a href="classpubnub__qt.html#ac78b2594c752a5770c2f3b1b8be464ff">More...</a><br /></td></tr>
<tr class="separator:ac78b2594c752a5770c2f3b1b8be464ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a4256c7af2a70808c93846224d3aca241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a4256c7af2a70808c93846224d3aca241">outcome</a> (pubnub_res result)</td></tr>
<tr class="memdesc:a4256c7af2a70808c93846224d3aca241"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is sent on the outcome of the transaction/operation.  <a href="#a4256c7af2a70808c93846224d3aca241">More...</a><br /></td></tr>
<tr class="separator:a4256c7af2a70808c93846224d3aca241"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f765d07de9fcffc4e25a0023398d2a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a7f765d07de9fcffc4e25a0023398d2a5">pubnub_qt</a> (QString pubkey, QString keysub)</td></tr>
<tr class="memdesc:a7f765d07de9fcffc4e25a0023398d2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Pubnub Qt context.  <a href="#a7f765d07de9fcffc4e25a0023398d2a5">More...</a><br /></td></tr>
<tr class="separator:a7f765d07de9fcffc4e25a0023398d2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac540ff68da4adf870d2d6f65df070697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ac540ff68da4adf870d2d6f65df070697">set_auth</a> (QString const &amp;<a class="el" href="classpubnub__qt.html#a56a93e83d2de733e6d927407ad8265c9">auth</a>)</td></tr>
<tr class="memdesc:ac540ff68da4adf870d2d6f65df070697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authentication key to be used in this context.  <a href="#ac540ff68da4adf870d2d6f65df070697">More...</a><br /></td></tr>
<tr class="separator:ac540ff68da4adf870d2d6f65df070697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a93e83d2de733e6d927407ad8265c9"><td class="memItemLeft" align="right" valign="top"><a id="a56a93e83d2de733e6d927407ad8265c9"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a56a93e83d2de733e6d927407ad8265c9">auth</a> () const</td></tr>
<tr class="memdesc:a56a93e83d2de733e6d927407ad8265c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current auth key. <br /></td></tr>
<tr class="separator:a56a93e83d2de733e6d927407ad8265c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6de5c0409520182ceb6a213a21efc72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ad6de5c0409520182ceb6a213a21efc72">set_uuid</a> (QString const &amp;<a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a>)</td></tr>
<tr class="memdesc:ad6de5c0409520182ceb6a213a21efc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the UUID to be used in this context.  <a href="#ad6de5c0409520182ceb6a213a21efc72">More...</a><br /></td></tr>
<tr class="separator:ad6de5c0409520182ceb6a213a21efc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9d40cec33fe7055b5bba3b79ccea52"><td class="memItemLeft" align="right" valign="top"><a id="a4a9d40cec33fe7055b5bba3b79ccea52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a4a9d40cec33fe7055b5bba3b79ccea52">set_uuid_v4_random</a> ()</td></tr>
<tr class="memdesc:a4a9d40cec33fe7055b5bba3b79ccea52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the UUID to a random value, according to stadard v4 representation. <br /></td></tr>
<tr class="separator:a4a9d40cec33fe7055b5bba3b79ccea52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743f80821fee1e0bc4b902678ab19ae0"><td class="memItemLeft" align="right" valign="top"><a id="a743f80821fee1e0bc4b902678ab19ae0"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a> () const</td></tr>
<tr class="memdesc:a743f80821fee1e0bc4b902678ab19ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current UUID value (string) <br /></td></tr>
<tr class="separator:a743f80821fee1e0bc4b902678ab19ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0863e6751a32bc678a564af43a6f7997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a0863e6751a32bc678a564af43a6f7997">set_origin</a> (QString const &amp;<a class="el" href="classpubnub__qt.html#a37a2e194b4b7009f29619111cffba4f1">origin</a>)</td></tr>
<tr class="memdesc:a0863e6751a32bc678a564af43a6f7997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Pubnub origin to use, that is, the protocol (http or https) and host part of the URL.  <a href="#a0863e6751a32bc678a564af43a6f7997">More...</a><br /></td></tr>
<tr class="separator:a0863e6751a32bc678a564af43a6f7997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a2e194b4b7009f29619111cffba4f1"><td class="memItemLeft" align="right" valign="top"><a id="a37a2e194b4b7009f29619111cffba4f1"></a>
QString const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a37a2e194b4b7009f29619111cffba4f1">origin</a> () const</td></tr>
<tr class="memdesc:a37a2e194b4b7009f29619111cffba4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current origin. <br /></td></tr>
<tr class="separator:a37a2e194b4b7009f29619111cffba4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2503f38b19f3fa30bfd2d0bc9b80f49"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#aa2503f38b19f3fa30bfd2d0bc9b80f49">get</a> () const</td></tr>
<tr class="memdesc:aa2503f38b19f3fa30bfd2d0bc9b80f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string of an arrived message or other element of the response to an operation/transaction.  <a href="#aa2503f38b19f3fa30bfd2d0bc9b80f49">More...</a><br /></td></tr>
<tr class="separator:aa2503f38b19f3fa30bfd2d0bc9b80f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e42f8c9adff180a2ce17962b0f21485"><td class="memItemLeft" align="right" valign="top"><a id="a8e42f8c9adff180a2ce17962b0f21485"></a>
QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a8e42f8c9adff180a2ce17962b0f21485">get_all</a> () const</td></tr>
<tr class="memdesc:a8e42f8c9adff180a2ce17962b0f21485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all (remaining) messages from a context. <br /></td></tr>
<tr class="separator:a8e42f8c9adff180a2ce17962b0f21485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c769eb4026b1123a5ce5750c8f26c9c"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a4c769eb4026b1123a5ce5750c8f26c9c">get_channel</a> () const</td></tr>
<tr class="memdesc:a4c769eb4026b1123a5ce5750c8f26c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string of a fetched subscribe operation/transaction's next channel.  <a href="#a4c769eb4026b1123a5ce5750c8f26c9c">More...</a><br /></td></tr>
<tr class="separator:a4c769eb4026b1123a5ce5750c8f26c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62330511543a8aec201db219d18f181"><td class="memItemLeft" align="right" valign="top"><a id="ac62330511543a8aec201db219d18f181"></a>
QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ac62330511543a8aec201db219d18f181">get_all_channels</a> () const</td></tr>
<tr class="memdesc:ac62330511543a8aec201db219d18f181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all (remaining) channels from a context. <br /></td></tr>
<tr class="separator:ac62330511543a8aec201db219d18f181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a7a107aa4c1865c05fd1ffe24694b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a29a7a107aa4c1865c05fd1ffe24694b7">cancel</a> ()</td></tr>
<tr class="memdesc:a29a7a107aa4c1865c05fd1ffe24694b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels an ongoing API transaction.  <a href="#a29a7a107aa4c1865c05fd1ffe24694b7">More...</a><br /></td></tr>
<tr class="separator:a29a7a107aa4c1865c05fd1ffe24694b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac546c06cc9cfe2c78e1102f7f6eb0b6"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#aac546c06cc9cfe2c78e1102f7f6eb0b6">publish</a> (QString const &amp;channel, QString const &amp;message)</td></tr>
<tr class="memdesc:aac546c06cc9cfe2c78e1102f7f6eb0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish the <code>message</code> (in JSON format) on <code>p</code> channel, using the <code>p</code> context.  <a href="#aac546c06cc9cfe2c78e1102f7f6eb0b6">More...</a><br /></td></tr>
<tr class="separator:aac546c06cc9cfe2c78e1102f7f6eb0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6af2191e820b3b1f817db5190b583a0"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ab6af2191e820b3b1f817db5190b583a0">publish_via_post</a> (QString const &amp;channel, QByteArray const &amp;message)</td></tr>
<tr class="memdesc:ab6af2191e820b3b1f817db5190b583a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initiates 'publish' transaction via POST method.  <a href="#ab6af2191e820b3b1f817db5190b583a0">More...</a><br /></td></tr>
<tr class="separator:ab6af2191e820b3b1f817db5190b583a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e91803e59b957cc2dd52cff45fafe0"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ae7e91803e59b957cc2dd52cff45fafe0">publish_via_post</a> (QString const &amp;channel, QJsonDocument const &amp;message)</td></tr>
<tr class="memdesc:ae7e91803e59b957cc2dd52cff45fafe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates 'publish' transaction via POST method.  <a href="#ae7e91803e59b957cc2dd52cff45fafe0">More...</a><br /></td></tr>
<tr class="separator:ae7e91803e59b957cc2dd52cff45fafe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d439eaf90b7da2b1d0c3bcc3391ffec"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a5d439eaf90b7da2b1d0c3bcc3391ffec">publish_via_post_with_gzip</a> (QString const &amp;channel, QByteArray const &amp;message)</td></tr>
<tr class="memdesc:a5d439eaf90b7da2b1d0c3bcc3391ffec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initiates 'publish' transaction via POST method with message gzipped if convenient.  <a href="#a5d439eaf90b7da2b1d0c3bcc3391ffec">More...</a><br /></td></tr>
<tr class="separator:a5d439eaf90b7da2b1d0c3bcc3391ffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60081cdfb6c326b01ee58f92d74ad9d0"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a60081cdfb6c326b01ee58f92d74ad9d0">publish_via_post_with_gzip</a> (QString const &amp;channel, QJsonDocument const &amp;message)</td></tr>
<tr class="memdesc:a60081cdfb6c326b01ee58f92d74ad9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates 'publish' transaction via POST method with message gzipped if convenient.  <a href="#a60081cdfb6c326b01ee58f92d74ad9d0">More...</a><br /></td></tr>
<tr class="separator:a60081cdfb6c326b01ee58f92d74ad9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9193d83e80e31aea968083025155b6e"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ae9193d83e80e31aea968083025155b6e">subscribe</a> (QString const &amp;channel, QString const &amp;channel_group=&quot;&quot;)</td></tr>
<tr class="memdesc:ae9193d83e80e31aea968083025155b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to <code>channel</code> and/or <code>channel_group</code>.  <a href="#ae9193d83e80e31aea968083025155b6e">More...</a><br /></td></tr>
<tr class="separator:ae9193d83e80e31aea968083025155b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3467ef3789df236fa4a5d01674ea54d7"><td class="memItemLeft" align="right" valign="top"><a id="a3467ef3789df236fa4a5d01674ea54d7"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a3467ef3789df236fa4a5d01674ea54d7">subscribe</a> (QStringList const &amp;channel, QStringList const &amp;channel_group=QStringList())</td></tr>
<tr class="memdesc:a3467ef3789df236fa4a5d01674ea54d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to subscribe to several channels and or channel groups by giving a (string) list of them. <br /></td></tr>
<tr class="separator:a3467ef3789df236fa4a5d01674ea54d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa609236d735feef9114db984b7d9ec27"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#aa609236d735feef9114db984b7d9ec27">leave</a> (QString const &amp;channel, QString const &amp;channel_group=&quot;&quot;)</td></tr>
<tr class="memdesc:aa609236d735feef9114db984b7d9ec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave the <code>channel</code>.  <a href="#aa609236d735feef9114db984b7d9ec27">More...</a><br /></td></tr>
<tr class="separator:aa609236d735feef9114db984b7d9ec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c34da19c6679b452cd8ff244398e319"><td class="memItemLeft" align="right" valign="top"><a id="a0c34da19c6679b452cd8ff244398e319"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a0c34da19c6679b452cd8ff244398e319">leave</a> (QStringList const &amp;channel, QStringList const &amp;channel_group=QStringList())</td></tr>
<tr class="memdesc:a0c34da19c6679b452cd8ff244398e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to leave from several channels and or channel groups by giving a (string) list of them. <br /></td></tr>
<tr class="separator:a0c34da19c6679b452cd8ff244398e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25daae16caabca4566b290b126e9891"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ae25daae16caabca4566b290b126e9891">time</a> ()</td></tr>
<tr class="memdesc:ae25daae16caabca4566b290b126e9891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current Pubnub time token .  <a href="#ae25daae16caabca4566b290b126e9891">More...</a><br /></td></tr>
<tr class="separator:ae25daae16caabca4566b290b126e9891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea76fb64426077db19dcee24941a4dc"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#adea76fb64426077db19dcee24941a4dc">history</a> (QString const &amp;channel, unsigned count=100, bool include_token=false)</td></tr>
<tr class="memdesc:adea76fb64426077db19dcee24941a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the message history for the <code>channel</code>.  <a href="#adea76fb64426077db19dcee24941a4dc">More...</a><br /></td></tr>
<tr class="separator:adea76fb64426077db19dcee24941a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab395e15acdfbd629df9d4ddf9ceb9fbd"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ab395e15acdfbd629df9d4ddf9ceb9fbd">history</a> (QString const &amp;channel, unsigned count, bool include_token, QString const &amp;start, bool reverse, QString const &amp;end, bool string_token)</td></tr>
<tr class="memdesc:ab395e15acdfbd629df9d4ddf9ceb9fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the "extended" history, with all the options and no defaults.  <a href="#ab395e15acdfbd629df9d4ddf9ceb9fbd">More...</a><br /></td></tr>
<tr class="separator:ab395e15acdfbd629df9d4ddf9ceb9fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d02ef0b36f6bc62cc0b0639476849a"><td class="memItemLeft" align="right" valign="top"><a id="a78d02ef0b36f6bc62cc0b0639476849a"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>get_error_message</b> ()</td></tr>
<tr class="separator:a78d02ef0b36f6bc62cc0b0639476849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58f4f2a4cbe8e2d151a8fa78c952242"><td class="memItemLeft" align="right" valign="top"><a id="ac58f4f2a4cbe8e2d151a8fa78c952242"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><b>message_counts</b> (QString const &amp;channel, QString const &amp;timetoken)</td></tr>
<tr class="separator:ac58f4f2a4cbe8e2d151a8fa78c952242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00096c26bb76b67563183f5221af8236"><td class="memItemLeft" align="right" valign="top"><a id="a00096c26bb76b67563183f5221af8236"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><b>message_counts</b> (QStringList const &amp;channel, QString const &amp;timetoken)</td></tr>
<tr class="separator:a00096c26bb76b67563183f5221af8236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83132fd0caf73c3304fae7b43af2b42f"><td class="memItemLeft" align="right" valign="top"><a id="a83132fd0caf73c3304fae7b43af2b42f"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><b>message_counts</b> (QString const &amp;channel, QStringList const &amp;channel_timetoken)</td></tr>
<tr class="separator:a83132fd0caf73c3304fae7b43af2b42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b921d8920d2230b7d99709d3ab7ede3"><td class="memItemLeft" align="right" valign="top"><a id="a3b921d8920d2230b7d99709d3ab7ede3"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><b>message_counts</b> (QStringList const &amp;channel, QStringList const &amp;channel_timetoken)</td></tr>
<tr class="separator:a3b921d8920d2230b7d99709d3ab7ede3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bd411cf096c05572dd376dad5a0c34"><td class="memItemLeft" align="right" valign="top"><a id="af7bd411cf096c05572dd376dad5a0c34"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><b>message_counts</b> (QVector&lt; QPair&lt; QString, QString &gt;&gt; const &amp;channel_timetokens)</td></tr>
<tr class="separator:af7bd411cf096c05572dd376dad5a0c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2304b64899e5576c7b7272400989e62"><td class="memItemLeft" align="right" valign="top"><a id="ab2304b64899e5576c7b7272400989e62"></a>
QMap&lt; QString, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_channel_message_counts</b> ()</td></tr>
<tr class="separator:ab2304b64899e5576c7b7272400989e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7352d782f88d29da1716476681408189"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a7352d782f88d29da1716476681408189">here_now</a> (QString const &amp;channel, QString const &amp;channel_group=&quot;&quot;)</td></tr>
<tr class="memdesc:a7352d782f88d29da1716476681408189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently present users on a <code>channel</code> and/or <code>channel_group</code>.  <a href="#a7352d782f88d29da1716476681408189">More...</a><br /></td></tr>
<tr class="separator:a7352d782f88d29da1716476681408189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4207b8e246f2fb86506f18beda9a7b"><td class="memItemLeft" align="right" valign="top"><a id="a4f4207b8e246f2fb86506f18beda9a7b"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a4f4207b8e246f2fb86506f18beda9a7b">here_now</a> (QStringList const &amp;channel, QStringList const &amp;channel_group=QStringList())</td></tr>
<tr class="memdesc:a4f4207b8e246f2fb86506f18beda9a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to get "here now" info from several channels and or channel groups by giving a (string) list of them. <br /></td></tr>
<tr class="separator:a4f4207b8e246f2fb86506f18beda9a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b2419ec900aef03f189587a183b64c"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a50b2419ec900aef03f189587a183b64c">global_here_now</a> ()</td></tr>
<tr class="memdesc:a50b2419ec900aef03f189587a183b64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently present users on all channel.  <a href="#a50b2419ec900aef03f189587a183b64c">More...</a><br /></td></tr>
<tr class="separator:a50b2419ec900aef03f189587a183b64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5216a8cc041a648602f855ac3e8faa23"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a5216a8cc041a648602f855ac3e8faa23">where_now</a> (QString const &amp;<a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a5216a8cc041a648602f855ac3e8faa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently present users on a <code>channel</code> and/or <code>channel_group</code>.  <a href="#a5216a8cc041a648602f855ac3e8faa23">More...</a><br /></td></tr>
<tr class="separator:a5216a8cc041a648602f855ac3e8faa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94072485160045b9e491f4e52408f2c"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ab94072485160045b9e491f4e52408f2c">set_state</a> (QString const &amp;channel, QString const &amp;channel_group, QString const &amp;<a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a>, QString const &amp;state)</td></tr>
<tr class="memdesc:ab94072485160045b9e491f4e52408f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets some state for the <code>channel</code> and/or @channel_group for a user, identified by <code>uuid</code>.  <a href="#ab94072485160045b9e491f4e52408f2c">More...</a><br /></td></tr>
<tr class="separator:ab94072485160045b9e491f4e52408f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac813f010d689e0c5e2c333e0d4d960cd"><td class="memItemLeft" align="right" valign="top"><a id="ac813f010d689e0c5e2c333e0d4d960cd"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ac813f010d689e0c5e2c333e0d4d960cd">set_state</a> (QStringList const &amp;channel, QStringList const &amp;channel_group, QString const &amp;<a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a>, QString const &amp;state)</td></tr>
<tr class="memdesc:ac813f010d689e0c5e2c333e0d4d960cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to set state from several channels and or channel groups by giving a (string) list of them. <br /></td></tr>
<tr class="separator:ac813f010d689e0c5e2c333e0d4d960cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cce9003bcdd2bb79befd11d722ecb1e"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a3cce9003bcdd2bb79befd11d722ecb1e">state_get</a> (QString const &amp;channel, QString const &amp;channel_group=&quot;&quot;, QString const &amp;<a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a3cce9003bcdd2bb79befd11d722ecb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets some state for the <code>channel</code> and/or @channel_group for a user, identified by <code>uuid</code>.  <a href="#a3cce9003bcdd2bb79befd11d722ecb1e">More...</a><br /></td></tr>
<tr class="separator:a3cce9003bcdd2bb79befd11d722ecb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a983d06f2e25ca3ca47fa9082d9c85b"><td class="memItemLeft" align="right" valign="top"><a id="a8a983d06f2e25ca3ca47fa9082d9c85b"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a8a983d06f2e25ca3ca47fa9082d9c85b">state_get</a> (QStringList const &amp;channel, QStringList const &amp;channel_group=QStringList(), QString const &amp;<a class="el" href="classpubnub__qt.html#a743f80821fee1e0bc4b902678ab19ae0">uuid</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a8a983d06f2e25ca3ca47fa9082d9c85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to get state from several channels and or channel groups by giving a (string) list of them. <br /></td></tr>
<tr class="separator:a8a983d06f2e25ca3ca47fa9082d9c85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10da8dcaa610a2b62069a366eeb6179d"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a10da8dcaa610a2b62069a366eeb6179d">remove_channel_group</a> (QString const &amp;channel_group)</td></tr>
<tr class="memdesc:a10da8dcaa610a2b62069a366eeb6179d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code>channel_group</code> and all its channels.  <a href="#a10da8dcaa610a2b62069a366eeb6179d">More...</a><br /></td></tr>
<tr class="separator:a10da8dcaa610a2b62069a366eeb6179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd3390443f273f7d865fd3e192827f1"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a1dd3390443f273f7d865fd3e192827f1">remove_channel_from_group</a> (QString const &amp;channel, QString const &amp;channel_group)</td></tr>
<tr class="memdesc:a1dd3390443f273f7d865fd3e192827f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <code>channel</code> from the <code>channel_group</code> .  <a href="#a1dd3390443f273f7d865fd3e192827f1">More...</a><br /></td></tr>
<tr class="separator:a1dd3390443f273f7d865fd3e192827f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b935f5e9a10e18f6dfec1081cdd391"><td class="memItemLeft" align="right" valign="top"><a id="a75b935f5e9a10e18f6dfec1081cdd391"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a75b935f5e9a10e18f6dfec1081cdd391">remove_channel_from_group</a> (QStringList const &amp;channel, QString const &amp;channel_group)</td></tr>
<tr class="memdesc:a75b935f5e9a10e18f6dfec1081cdd391"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to remove channels from channel group by giving (string) lists of them. <br /></td></tr>
<tr class="separator:a75b935f5e9a10e18f6dfec1081cdd391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8156bb48d1f2e05b04f07aa154d4a539"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a8156bb48d1f2e05b04f07aa154d4a539">add_channel_to_group</a> (QString const &amp;channel, QString const &amp;channel_group)</td></tr>
<tr class="memdesc:a8156bb48d1f2e05b04f07aa154d4a539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <code>channel</code> to the <code>channel_group</code> .  <a href="#a8156bb48d1f2e05b04f07aa154d4a539">More...</a><br /></td></tr>
<tr class="separator:a8156bb48d1f2e05b04f07aa154d4a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50e06e3089dd46ac33f6bad65b364ee"><td class="memItemLeft" align="right" valign="top"><a id="aa50e06e3089dd46ac33f6bad65b364ee"></a>
pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#aa50e06e3089dd46ac33f6bad65b364ee">add_channel_to_group</a> (QStringList const &amp;channel, QString const &amp;channel_group)</td></tr>
<tr class="memdesc:aa50e06e3089dd46ac33f6bad65b364ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper method to add channels to channel group by giving (string) lists of them. <br /></td></tr>
<tr class="separator:aa50e06e3089dd46ac33f6bad65b364ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e2d182fb3ffd15f9e455ccab120beb"><td class="memItemLeft" align="right" valign="top">pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a05e2d182fb3ffd15f9e455ccab120beb">list_channel_group</a> (QString const &amp;channel_group)</td></tr>
<tr class="memdesc:a05e2d182fb3ffd15f9e455ccab120beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all channels of a <code>channel_group</code>.  <a href="#a05e2d182fb3ffd15f9e455ccab120beb">More...</a><br /></td></tr>
<tr class="separator:a05e2d182fb3ffd15f9e455ccab120beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af115e30490966f12c77b680b7d1d767e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#af115e30490966f12c77b680b7d1d767e">last_http_code</a> () const</td></tr>
<tr class="memdesc:af115e30490966f12c77b680b7d1d767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HTTP code of the last transaction.  <a href="#af115e30490966f12c77b680b7d1d767e">More...</a><br /></td></tr>
<tr class="separator:af115e30490966f12c77b680b7d1d767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fb3c9f7a7b2b735c3e5d63c9269fec"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ad5fb3c9f7a7b2b735c3e5d63c9269fec">last_publish_result</a> () const</td></tr>
<tr class="memdesc:ad5fb3c9f7a7b2b735c3e5d63c9269fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result string that Pubnub returned in the reply to the last publish transaction.  <a href="#ad5fb3c9f7a7b2b735c3e5d63c9269fec">More...</a><br /></td></tr>
<tr class="separator:ad5fb3c9f7a7b2b735c3e5d63c9269fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ad9c5b4b196a4247dbc2245cc4e1ab"><td class="memItemLeft" align="right" valign="top"><a id="ad7ad9c5b4b196a4247dbc2245cc4e1ab"></a>
pubnub_publish_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ad7ad9c5b4b196a4247dbc2245cc4e1ab">parse_last_publish_result</a> ()</td></tr>
<tr class="memdesc:ad7ad9c5b4b196a4247dbc2245cc4e1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of parsing the last publish transaction's response from the server. <br /></td></tr>
<tr class="separator:ad7ad9c5b4b196a4247dbc2245cc4e1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2460362b0494410c579dc6a8fefc08be"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a2460362b0494410c579dc6a8fefc08be">last_time_token</a> () const</td></tr>
<tr class="memdesc:a2460362b0494410c579dc6a8fefc08be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time token of the last subscribe operation.  <a href="#a2460362b0494410c579dc6a8fefc08be">More...</a><br /></td></tr>
<tr class="separator:a2460362b0494410c579dc6a8fefc08be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5801bd135924e9d99224ea5a2138f5e2"><td class="memItemLeft" align="right" valign="top"><a id="a5801bd135924e9d99224ea5a2138f5e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a5801bd135924e9d99224ea5a2138f5e2">use_http_keep_alive</a> ()</td></tr>
<tr class="memdesc:a5801bd135924e9d99224ea5a2138f5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use HTTP Keep-Alive on the context for subsequent transactions. <br /></td></tr>
<tr class="separator:a5801bd135924e9d99224ea5a2138f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cf063e89472162440107796c4a45f8"><td class="memItemLeft" align="right" valign="top"><a id="a30cf063e89472162440107796c4a45f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a30cf063e89472162440107796c4a45f8">dont_use_http_keep_alive</a> ()</td></tr>
<tr class="memdesc:a30cf063e89472162440107796c4a45f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't use HTTP Keep-Alive on the context for subsequent transactions. <br /></td></tr>
<tr class="separator:a30cf063e89472162440107796c4a45f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e82087f1803438dcd566556a701c4f"><td class="memItemLeft" align="right" valign="top"><a id="a54e82087f1803438dcd566556a701c4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a54e82087f1803438dcd566556a701c4f">set_ssl_options</a> (ssl_opts options)</td></tr>
<tr class="memdesc:a54e82087f1803438dcd566556a701c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SSL options for this context. <br /></td></tr>
<tr class="separator:a54e82087f1803438dcd566556a701c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dc1204ab46ac7a369993d8dbe63745"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#a79dc1204ab46ac7a369993d8dbe63745">set_transaction_timeout</a> (int duration_ms)</td></tr>
<tr class="memdesc:a79dc1204ab46ac7a369993d8dbe63745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the duration of the transaction timeout.  <a href="#a79dc1204ab46ac7a369993d8dbe63745">More...</a><br /></td></tr>
<tr class="separator:a79dc1204ab46ac7a369993d8dbe63745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab791fa3290c59feef9249c940ec2124b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpubnub__qt.html#ab791fa3290c59feef9249c940ec2124b">transaction_timeout_get</a> ()</td></tr>
<tr class="memdesc:ab791fa3290c59feef9249c940ec2124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current transaction duration, in milliseconds.  <a href="#ab791fa3290c59feef9249c940ec2124b">More...</a><br /></td></tr>
<tr class="separator:ab791fa3290c59feef9249c940ec2124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pubnub client "context" for Qt. </p>
<p>Represents a Pubnub "context". One context handles at most one Pubnub API transaction/operation at a time. It is similar in the way it works with other C-core Pubnub clients, but there are a few differences that are Qt-specific.</p>
<p>Unlike the C++ wrapper, which wraps a "full featured" C-core platform, this is a "Qt-native C-core" of sorts. It provides it's own (Qt) API, while using us much of C-core modules as posible.</p>
<p>The outcome of an operation is reported to a user via a Qt signal. There is no "sync" or "callback" interface, though Qt signals are similar to callbacks and we might introduce a "sync" interface.</p>
<p>This is not a widget, it is a pure "communication" class, which you can use both in Qt GUI and Qt command line applications. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac78b2594c752a5770c2f3b1b8be464ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78b2594c752a5770c2f3b1b8be464ff">&#9670;&nbsp;</a></span>ssl_opt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpubnub__qt.html#ac78b2594c752a5770c2f3b1b8be464ff">pubnub_qt::ssl_opt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for SSL/TLS transport. </p>
<p>These are designed to be used as "bit-masks", for which purpose there are overloaded <code>&amp;</code> and <code>|</code> (bit-and and bit-or) operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac78b2594c752a5770c2f3b1b8be464ffa996f6933fbbf34a8e40a453e777a5612"></a>useSSL&#160;</td><td class="fielddoc"><p>Should the PubNub client establish the connection to PubNub using SSL? (default: YES) </p>
</td></tr>
<tr><td class="fieldname"><a id="ac78b2594c752a5770c2f3b1b8be464ffa86f3a81927bb32b5d1d15df0ece0b8a8"></a>ignoreSecureConnectionRequirement&#160;</td><td class="fielddoc"><p>When SSL is enabled, should the client fallback to a non-SSL connection if it experiences issues handshaking across local proxies, firewalls, etc? (default: YES) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f765d07de9fcffc4e25a0023398d2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f765d07de9fcffc4e25a0023398d2a5">&#9670;&nbsp;</a></span>pubnub_qt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_qt::pubnub_qt </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>pubkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>keysub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Pubnub Qt context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pubkey</td><td>The publish key to use in the new context </td></tr>
    <tr><td class="paramname">keysub</td><td>The subscribe key to use in the new context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8156bb48d1f2e05b04f07aa154d4a539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8156bb48d1f2e05b04f07aa154d4a539">&#9670;&nbsp;</a></span>add_channel_to_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::add_channel_to_group </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a <code>channel</code> to the <code>channel_group</code> . </p>
<p>This actually means "initiate a add_channel_to_channel_group transaction". It can be thought of as an update against the "channel group database".</p>
<p>If the channel group doesn't exist, this implicitly adds (creates) it.</p>
<p>If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"message": the string/message describing the status ("OK"...)</li>
</ul>
<p>You can't add a channel to a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to add </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel group to add to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a29a7a107aa4c1865c05fd1ffe24694b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a7a107aa4c1865c05fd1ffe24694b7">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_qt::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels an ongoing API transaction. </p>
<p>The outcome is not guaranteed to be #PNR_CANCELLED like in other C-core based APIs, because it depends on what Qt actually does with our request to abort. But, in the regular case, it will be #PNR_CANCELLED. </p>

</div>
</div>
<a id="aa2503f38b19f3fa30bfd2d0bc9b80f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2503f38b19f3fa30bfd2d0bc9b80f49">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString pubnub_qt::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string of an arrived message or other element of the response to an operation/transaction. </p>
<p>Message(s) arrive on finish of a subscribe operation, while for other operations this will give access to the whole response or the next element of the response. That is documented in the function that starts the operation.</p>
<p>Subsequent call to this function will return the next message (if any). All messages are from the channel(s) the last operation was for.</p>
<dl class="section note"><dt>Note</dt><dd>Context doesn't keep track of the channel(s) you subscribed to. This is a memory saving design decision, as most users won't change the channel(s) they subscribe too. </dd></dl>

</div>
</div>
<a id="a4c769eb4026b1123a5ce5750c8f26c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c769eb4026b1123a5ce5750c8f26c9c">&#9670;&nbsp;</a></span>get_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString pubnub_qt::get_channel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string of a fetched subscribe operation/transaction's next channel. </p>
<p>Each transaction may hold a list of channels, and this functions provides a way to read them. Subsequent call to this function will return the next channel (if any).</p>
<dl class="section note"><dt>Note</dt><dd>You don't have to read all (or any) of the channels before you start a new transaction. </dd></dl>

</div>
</div>
<a id="a50b2419ec900aef03f189587a183b64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b2419ec900aef03f189587a183b64c">&#9670;&nbsp;</a></span>global_here_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::global_here_now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently present users on all channel. </p>
<p>This actually means "initiate a global here_now transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be the same as for "multi-channel" response for pubnub_here_now(), if we queried against all currently available channels.</p>
<p>You can't get list of currently present users if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to get presence info for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a7352d782f88d29da1716476681408189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7352d782f88d29da1716476681408189">&#9670;&nbsp;</a></span>here_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::here_now </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently present users on a <code>channel</code> and/or <code>channel_group</code>. </p>
<p>This actually means "initiate a here_now
transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="classpubnub__qt.html#aa2503f38b19f3fa30bfd2d0bc9b80f49" title="Returns the string of an arrived message or other element of the response to an operation/transaction...">get()</a> as one message, a JSON object. Following keys are always present:</p><ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
</ul>
<p>If doing a query on a single channel, following keys are present:</p><ul>
<li>"uuids": an array of UUIDs of currently present users</li>
<li>"occupancy": the number of currently present users in the channel</li>
</ul>
<p>If doing a query on more channels, a key "payload" is present, which is a JSON object whose keys are:</p>
<ul>
<li>"channels": a JSON object with keys being the names of the channels and their values JSON objects with keys "uuids" and "occupancy" with the meaning the same as for query on a single channel</li>
<li>"total_channels": the number of channels for which the presence is given (in "payload")</li>
<li>"total_occupancy": total number of users present in all channels</li>
</ul>
<p>If <code>channel</code> is empty or null, then <code>channel_group</code> cannot be empty or null and you will get presence info only for the channel group. It goes both ways: if <code>channel_group</code> is empty, then <code>channel</code> cannot be empty and you will get presence info only for the channel.</p>
<p>You can't get list of currently present users if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to get presence info for. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel name (or comma-delimited list of channel group names) to get presence info for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="adea76fb64426077db19dcee24941a4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea76fb64426077db19dcee24941a4dc">&#9670;&nbsp;</a></span>history() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::history </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_token</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the message history for the <code>channel</code>. </p>
<p>This actually means "initiate a history transaction/operation".</p>
<p>If transaction is successful, the gotten messages will be available via the <a class="el" href="classpubnub__qt.html#aa2503f38b19f3fa30bfd2d0bc9b80f49" title="Returns the string of an arrived message or other element of the response to an operation/transaction...">get()</a>, yielding exactly three messages (or, rather, elements). The first will be a JSON array of gotten messages, and the second and third will be the timestamps of the first and the last message from that array.</p>
<p>Also, if you select to <code>include_token</code>, then the JSON array you get will not be a simple array of gotten messages, but rather an array of JSON objects, having keys <code>message</code> with value the actual message, and <code>timetoken</code> with the time token of that particular message.</p>
<p>You can't get history if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name to get message history for. This <em>can't</em> be a comma separated list of channels. </td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of messages to get. If there are less than this available on the <code>channel</code>, you'll get less, but you can't get more. </td></tr>
    <tr><td class="paramname">include_token</td><td>If true, include the time token for every gotten message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="ab395e15acdfbd629df9d4ddf9ceb9fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab395e15acdfbd629df9d4ddf9ceb9fbd">&#9670;&nbsp;</a></span>history() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::history </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>string_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the "extended" history, with all the options and no defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name to get message history for. This <em>can't</em> be a comma separated list of channels.</td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of messages to get. If there are less than this available on the <code>channel</code>, you'll get less, but you can't get more.</td></tr>
    <tr><td class="paramname">include_token</td><td>If true, include the time token for every gotten message</td></tr>
    <tr><td class="paramname">start</td><td>Lets you select a start date, in Timetoken format. If not provided, it will default to current time. Page through results by providing a start OR end time token. Retrieve a slice of the time line by providing both a start AND end time token. start is exclusive  that is, the first item returned will be the one immediately after the start Timetoken value.</td></tr>
    <tr><td class="paramname">reverse</td><td>Direction of time traversal. False means timeline is traversed newest to oldest.</td></tr>
    <tr><td class="paramname">end</td><td>Lets you select an end date, in Timetoken format. If not provided, it will provide up to the number of messages defined in the count parameter. Page through results by providing a start OR end time token. Retrieve a slice of the time line by providing both a start AND end time token. End is exclusive  that is, if a message is associated exactly with the end Timetoken, it will be included in the result.</td></tr>
    <tr><td class="paramname">string_token</td><td>If false, the returned start and end Timetoken values will be returned as long ints. If 1, or true, the start and end Timetoken values will be returned as strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="af115e30490966f12c77b680b7d1d767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af115e30490966f12c77b680b7d1d767e">&#9670;&nbsp;</a></span>last_http_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pubnub_qt::last_http_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HTTP code of the last transaction. </p>
<p>If the transaction was succesfull, will return 0. </p>

</div>
</div>
<a id="ad5fb3c9f7a7b2b735c3e5d63c9269fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fb3c9f7a7b2b735c3e5d63c9269fec">&#9670;&nbsp;</a></span>last_publish_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString pubnub_qt::last_publish_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result string that Pubnub returned in the reply to the last publish transaction. </p>
<p>If the last transaction was not a publish one, will return an empty string, as will do on any other kind of error. </p>

</div>
</div>
<a id="a2460362b0494410c579dc6a8fefc08be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2460362b0494410c579dc6a8fefc08be">&#9670;&nbsp;</a></span>last_time_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString pubnub_qt::last_time_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time token of the last subscribe operation. </p>
<p>After init or a serious error, this will be "0". </p>

</div>
</div>
<a id="aa609236d735feef9114db984b7d9ec27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa609236d735feef9114db984b7d9ec27">&#9670;&nbsp;</a></span>leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::leave </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave the <code>channel</code>. </p>
<p>This actually means "initiate a leave
transaction". You should leave channel(s) when you want to subscribe to another in the same context to avoid loosing messages. Also, it is useful for tracking presence.</p>
<p>You can't leave if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to leave from. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel group name (or comma-delimited list of channel group names) to leave from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a05e2d182fb3ffd15f9e455ccab120beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e2d182fb3ffd15f9e455ccab120beb">&#9670;&nbsp;</a></span>list_channel_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::list_channel_group </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists all channels of a <code>channel_group</code>. </p>
<p>This actually means "initiate a list_channel_group transaction". It can be thought of as a query against the "channel group database".</p>
<p>If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"payload": JSON object with keys "group" with value the string of the channel group name and "channels" with value a JSON array of strings with names of the channels that belong to the group</li>
</ul>
<p>You can't remove a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_group</td><td>The channel group to list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a4256c7af2a70808c93846224d3aca241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4256c7af2a70808c93846224d3aca241">&#9670;&nbsp;</a></span>outcome</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_qt::outcome </td>
          <td>(</td>
          <td class="paramtype">pubnub_res&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This signal is sent on the outcome of the transaction/operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The final result (outcome) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac546c06cc9cfe2c78e1102f7f6eb0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac546c06cc9cfe2c78e1102f7f6eb0b6">&#9670;&nbsp;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::publish </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish the <code>message</code> (in JSON format) on <code>p</code> channel, using the <code>p</code> context. </p>
<p>This actually means "initiate a publish
transaction".</p>
<p>You can't publish if a transaction is in progress in <code>p</code> context.</p>
<p>If transaction is not successful (<code>PNR_PUBLISH_FAILED</code>), you can get the string describing the reason for failure by calling <a class="el" href="classpubnub__qt.html#ad5fb3c9f7a7b2b735c3e5d63c9269fec" title="Return the result string that Pubnub returned in the reply to the last publish transaction.">last_publish_result()</a>.</p>
<p>Keep in mind that the time token from the publish operation response is <em>not</em> parsed by the library, just relayed to the user. Only time-tokens from the subscribe operation are parsed by the library.</p>
<p>Also, for all error codes known at the time of this writing, the HTTP error will be set also, so the result of the Pubnub operation will not be <code>PNR_OK</code> (but you will still be able to get the result code and the description).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel (or comma-delimited list of channels) to publish to. </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish, expected to be in JSON format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="ab6af2191e820b3b1f817db5190b583a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6af2191e820b3b1f817db5190b583a0">&#9670;&nbsp;</a></span>publish_via_post() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::publish_via_post </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QByteArray const &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initiates 'publish' transaction via POST method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish, expected to be in JSON format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="ae7e91803e59b957cc2dd52cff45fafe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e91803e59b957cc2dd52cff45fafe0">&#9670;&nbsp;</a></span>publish_via_post() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::publish_via_post </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QJsonDocument const &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates 'publish' transaction via POST method. </p>
<p>Function receives 'Qt Json' document. Helpful if you're already using Qt support for Json in your code, ensuring message you're sending is valid Json, unlike the case when applying the function that receives byte array and doesn't check whether those bytes represent sound Json. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a5d439eaf90b7da2b1d0c3bcc3391ffec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d439eaf90b7da2b1d0c3bcc3391ffec">&#9670;&nbsp;</a></span>publish_via_post_with_gzip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::publish_via_post_with_gzip </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QByteArray const &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initiates 'publish' transaction via POST method with message gzipped if convenient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish, expected to be in JSON format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a60081cdfb6c326b01ee58f92d74ad9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60081cdfb6c326b01ee58f92d74ad9d0">&#9670;&nbsp;</a></span>publish_via_post_with_gzip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::publish_via_post_with_gzip </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QJsonDocument const &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates 'publish' transaction via POST method with message gzipped if convenient. </p>
<p>Function receives 'Qt Json' document. Helpful if you're already using Qt support for Json in your code, ensuring message you're sending is valid Json, unlike the case when applying the function that receives byte array and doesn't check whether those bytes represent sound Json. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a1dd3390443f273f7d865fd3e192827f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd3390443f273f7d865fd3e192827f1">&#9670;&nbsp;</a></span>remove_channel_from_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::remove_channel_from_group </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a <code>channel</code> from the <code>channel_group</code> . </p>
<p>This actually means "initiate a remove_channel_from_channel_group
transaction". It can be thought of as an update against the "channel group database".</p>
<p>You can't remove the last channel from a channel group. To do that, remove the channel group itself.</p>
<p>If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"message": the string/message describing the status ("OK"...)</li>
</ul>
<p>You can't remove a channel from a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_group</td><td>The channel to remove </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel group to remove from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a10da8dcaa610a2b62069a366eeb6179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10da8dcaa610a2b62069a366eeb6179d">&#9670;&nbsp;</a></span>remove_channel_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::remove_channel_group </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a <code>channel_group</code> and all its channels. </p>
<p>This actually means "initiate a remove_channel_group transaction". It can be thought of as an update against the "channel group database".</p>
<p>If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"message": the string/message describing the status ("OK"...)</li>
</ul>
<p>You can't remove a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_group</td><td>The channel group to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="ac540ff68da4adf870d2d6f65df070697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac540ff68da4adf870d2d6f65df070697">&#9670;&nbsp;</a></span>set_auth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_qt::set_auth </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>auth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the authentication key to be used in this context. </p>
<p>After construction it is empty (null), thus not used. Pass an empty (or null) string to stop using it. </p>

</div>
</div>
<a id="a0863e6751a32bc678a564af43a6f7997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0863e6751a32bc678a564af43a6f7997">&#9670;&nbsp;</a></span>set_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_qt::set_origin </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Pubnub origin to use, that is, the protocol (http or https) and host part of the URL. </p>
<p>By default, host is the generic host and protocol is https, unless SSL support is not included in your Qt. </p>

</div>
</div>
<a id="ab94072485160045b9e491f4e52408f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94072485160045b9e491f4e52408f2c">&#9670;&nbsp;</a></span>set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::set_state </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets some state for the <code>channel</code> and/or @channel_group for a user, identified by <code>uuid</code>. </p>
<p>This actually means "initiate a set
state transaction". It can be thought of as an update against the "presence database".</p>
<p>"State" has to be a JSON object (IOW, several "key-value" pairs).</p>
<p>If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object with following keys:</p><ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
<li>"payload" the state</li>
</ul>
<p>This will set the same state to all channels identified by <code>channel</code> and <code>channel_group</code>.</p>
<p>If <code>channel</code> is empty or null, then <code>channel_group</code> cannot be empty or null and you will set state only for the channel group. It goes both ways: if <code>channel_group</code> is empty, then <code>channel</code> cannot be empty and you will set state only for the channel.</p>
<p>You can't set state of channels if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to set state for. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel name (or comma-delimited list of channel group names) to set state for. </td></tr>
    <tr><td class="paramname">uuid</td><td>The UUID of the user for which to set state for. If empty or null, the current UUID of the context will be used. </td></tr>
    <tr><td class="paramname">state</td><td>Has to be a JSON object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="a79dc1204ab46ac7a369993d8dbe63745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dc1204ab46ac7a369993d8dbe63745">&#9670;&nbsp;</a></span>set_transaction_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pubnub_qt::set_transaction_timeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duration_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the duration of the transaction timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration_ms</td><td>the Duration of the transaction timeout, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: OK, else: error, timeout not set </dd></dl>

</div>
</div>
<a id="ad6de5c0409520182ceb6a213a21efc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6de5c0409520182ceb6a213a21efc72">&#9670;&nbsp;</a></span>set_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_qt::set_uuid </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the UUID to be used in this context. </p>
<p>After construction it is empty (null), thus not used. Pass an empty (or null) string to stop using it. </p>

</div>
</div>
<a id="a3cce9003bcdd2bb79befd11d722ecb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cce9003bcdd2bb79befd11d722ecb1e">&#9670;&nbsp;</a></span>state_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::state_get </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>uuid</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets some state for the <code>channel</code> and/or @channel_group for a user, identified by <code>uuid</code>. </p>
<p>This actually means "initiate a get
state transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object with following keys:</p><ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
<li>"payload": if querying against one channel the gotten state (a JSON object), otherwise a JSON object with the key "channels" whose value is a JSON object with keys the name of the channels and their respective values JSON objects of the gotten state</li>
</ul>
<p>If <code>channel</code> is empty or null, then <code>channel_group</code> cannot be empty or null and you will get state only for the channel group. It goes both ways: if <code>channel_group</code> is empty, then <code>channel</code> cannot be empty and you will get state only for the channel.</p>
<p>You can't set state of channels if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to set state for. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel name (or comma-delimited list of channel group names) to set state for. </td></tr>
    <tr><td class="paramname">uuid</td><td>The UUID of the user for which to set state for. If empty or null, the current UUID of the context will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="ae9193d83e80e31aea968083025155b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9193d83e80e31aea968083025155b6e">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::subscribe </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>channel_group</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to <code>channel</code> and/or <code>channel_group</code>. </p>
<p>This actually means "initiate a subscribe operation/transaction". The outcome will be retrieved by the "notification" API, which is different for different platforms. There are two APIs that are widely available - "sync" and "callback".</p>
<p>Messages published on <code>channel</code> and/or <code>channel_group</code> since the last subscribe transaction will be fetched, unless this is the first subscribe on this context after initialization or a serious error. In that "first" case, this will just retrieve the current time token, and that event is called "connect" in many pubnub SDKs, but in C-core we don't treat it any different. For that "first" case, you will receive a notification that subscribe has finished OK, but there will be no messages in the reply.</p>
<p>The <code>channel</code> and <code>channel_group</code> strings may contain multiple comma-separated channel (channel group) names, so only one call is needed to fetch messages from multiple channels (channel groups).</p>
<p>If <code>channel</code> is empty (or null), then <code>channel_group</code> cannot be empty (or null) and you will subscribe only to the channel group(s). It goes both ways: if <code>channel_group</code> is empty, then <code>channel</code> cannot be empty and you will subscribe only to the channel(s).</p>
<p>You can't subscribe if a transaction is in progress on the context.</p>
<p>Also, you can't subscribe if there are unread messages in the context (you read messages with pubnub_get()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to subscribe to. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel group name (or comma-delimited list of channel group names) to subscribe to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpubnub__qt.html#aa2503f38b19f3fa30bfd2d0bc9b80f49" title="Returns the string of an arrived message or other element of the response to an operation/transaction...">get</a> </dd></dl>

</div>
</div>
<a id="ae25daae16caabca4566b290b126e9891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25daae16caabca4566b290b126e9891">&#9670;&nbsp;</a></span>time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current Pubnub time token . </p>
<p>This actually means "initiate
a time transaction". Since time token is in the response to most Pubnub REST API calls, this is reserved mostly when you want to get a high-quality seed for a random number generator, or some such thing.</p>
<p>If transaction is successful, the gotten time will be the only message you can get with <a class="el" href="classpubnub__qt.html#aa2503f38b19f3fa30bfd2d0bc9b80f49" title="Returns the string of an arrived message or other element of the response to an operation/transaction...">get()</a>. It will be a (large) JSON integer.</p>
<p>You can't get time if a transaction is in progress on the context.</p>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a id="ab791fa3290c59feef9249c940ec2124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab791fa3290c59feef9249c940ec2124b">&#9670;&nbsp;</a></span>transaction_timeout_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pubnub_qt::transaction_timeout_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current transaction duration, in milliseconds. </p>

</div>
</div>
<a id="a5216a8cc041a648602f855ac3e8faa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5216a8cc041a648602f855ac3e8faa23">&#9670;&nbsp;</a></span>where_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pubnub_res pubnub_qt::where_now </td>
          <td>(</td>
          <td class="paramtype">QString const &amp;&#160;</td>
          <td class="paramname"><em>uuid</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently present users on a <code>channel</code> and/or <code>channel_group</code>. </p>
<p>This actually means "initiate a here_now
transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object with keys:</p>
<ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
<li>"payload": JSON object with a key "channels" which is an array of channels this user is present in</li>
</ul>
<p>You can't get channel presence for the user if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uuid</td><td>The UUID of the user to get the channel presence. If empty or null, the current UUID of the context will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="pubnub__qt_8h_source.html">pubnub_qt.h</a></li>
<li>pubnub_qt.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 5 2019 16:59:35 for Pubnub C-core Qt Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
